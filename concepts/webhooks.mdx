---
title: 'Webhooks'
description: 'Entenda como funcionam os webhooks e notifica√ß√µes autom√°ticas no ConnectVets Notes'
---

## O que s√£o Webhooks?

**Webhooks** s√£o notifica√ß√µes HTTP autom√°ticas que o ConnectVets Notes envia para sua aplica√ß√£o quando eventos importantes acontecem. Funcionam como "chamadas telef√¥nicas" autom√°ticas que avisam sobre mudan√ßas em tempo real.

<Info>
  **Analogia**: Se a **API** √© como "ligar para perguntar" o status, os **webhooks** s√£o como "receber uma liga√ß√£o" quando algo acontece.
</Info>

## Como Funcionam

### Fluxo do Webhook

```mermaid
sequenceDiagram
    participant App as Sua Aplica√ß√£o
    participant CV as ConnectVets Notes
    participant Queue as Fila de Processamento
    
    App->>CV: 1. POST /notes (upload √°udio)
    CV->>App: 2. 201 Created (nota criada)
    CV->>App: 3. Webhook: note.created
    
    CV->>Queue: 4. Adicionar √† fila
    Queue->>CV: 5. Iniciar processamento
    CV->>App: 6. Webhook: note.processing
    
    CV->>CV: 7. Transcrever + Analisar
    CV->>App: 8. Webhook: note.completed
    
    Note over App: Aplica√ß√£o atualiza<br/>interface automaticamente
```

### Ciclo de Vida de um Evento

<Steps>
  <Step title="Evento Ocorre">
    Algo importante acontece no ConnectVets (nota processada, erro, etc.)
  </Step>
  
  <Step title="Webhook Disparado">
    Sistema identifica que precisa notificar aplica√ß√µes registradas
  </Step>
  
  <Step title="HTTP POST Enviado">
    ConnectVets faz POST para URL configurada com dados do evento
  </Step>
  
  <Step title="Aplica√ß√£o Processa">
    Sua aplica√ß√£o recebe, valida e processa a notifica√ß√£o
  </Step>
  
  <Step title="Resposta HTTP">
    Aplica√ß√£o responde com status 200 confirmando recebimento
  </Step>
</Steps>

## Webhooks vs. Polling

### Compara√ß√£o T√©cnica

| Aspecto | üîî **Webhooks** | üîÑ **Polling** |
|---------|----------------|----------------|
| **Lat√™ncia** | &lt; 1 segundo | 5-30 segundos |
| **Efici√™ncia** | Alta (push) | Baixa (pull) |
| **Recursos** | M√≠nimos | Consome API calls |
| **Complexidade** | M√©dia | Simples |
| **Confiabilidade** | Requer retry | Auto-retry nativo |
| **Tempo Real** | ‚úÖ Verdadeiro | ‚ùå Simulado |

### Quando Usar Cada Um

<CardGroup cols={2}>
  <Card
    title="‚úÖ Use Webhooks Quando"
    icon="check"
  >
    - **Tempo real** √© cr√≠tico
    - **Efici√™ncia** de recursos importa
    - **Volume alto** de notas
    - **UX responsivo** necess√°rio
    - **Infraestrutura** robusta dispon√≠vel
  </Card>
  
  <Card
    title="‚úÖ Use Polling Quando"
    icon="clock"
  >
    - **Simplicidade** √© prioridade
    - **Volume baixo** de notas
    - **Infraestrutura** limitada
    - **Desenvolvimento r√°pido** necess√°rio
    - **Controle total** do timing
  </Card>
</CardGroup>

## Tipos de Eventos

### Eventos do Ciclo de Vida da Nota

<AccordionGroup>
  <Accordion title="üìù note.created">
    **Quando**: Nota criada com sucesso ap√≥s upload
    
    **Use para**:
    - Confirmar recebimento do √°udio
    - Criar registro no banco local
    - Notificar usu√°rio sobre in√≠cio
    - Atualizar interface (status "enviado")
    
    **Payload inclui**:
    ```json
    {
      "type": "note.created",
      "data": {
        "note": {
          "id": "note_abc123",
          "status": "pending",
          "metadata": { /* dados da consulta */ },
          "created_at": "2024-02-14T18:20:00Z"
        }
      }
    }
    ```
  </Accordion>
  
  <Accordion title="üîÑ note.processing">
    **Quando**: Processamento efetivamente iniciado
    
    **Use para**:
    - Atualizar status na interface
    - Notificar sobre in√≠cio do processamento
    - Registrar tempo de in√≠cio
    - Ativar indicadores de progresso
    
    **Diferen√ßa do `created`**: 
    - `created` = nota aceita e na fila
    - `processing` = processamento come√ßou
  </Accordion>
  
  <Accordion title="‚úÖ note.completed">
    **Quando**: Processamento conclu√≠do com sucesso
    
    **Use para**:
    - **Atualizar prontu√°rio** do paciente
    - **Notificar veterin√°rio** sobre conclus√£o
    - **Enviar email** com resultados
    - **Exibir transcri√ß√£o** e an√°lise
    - **Integrar com sistemas** internos
    
    **Payload inclui**:
    - Transcri√ß√£o completa
    - Se√ß√µes estruturadas (resumo, diagn√≥stico, tratamento)
    - Metadados finais
    - Timestamps de processamento
  </Accordion>
  
  <Accordion title="‚ùå note.failed">
    **Quando**: Processamento falhou definitivamente
    
    **Use para**:
    - **Notificar sobre erro** ao usu√°rio
    - **Registrar falha** para auditoria
    - **Alertar administrador** se necess√°rio
    - **Implementar retry** manual se aplic√°vel
    
    **Causas comuns**:
    - √Åudio inaud√≠vel ou corrompido
    - Formato n√£o suportado
    - Erro interno tempor√°rio
    - Viola√ß√£o de pol√≠ticas de conte√∫do
  </Accordion>
  
  <Accordion title="üìù note.updated">
    **Quando**: Nota modificada manualmente
    
    **Use para**:
    - Sincronizar altera√ß√µes manuais
    - Manter hist√≥rico de mudan√ßas
    - Notificar sobre corre√ß√µes
    - Atualizar caches locais
    
    **Cen√°rios**:
    - Corre√ß√£o manual da transcri√ß√£o
    - Atualiza√ß√£o de metadados
    - Reprocessamento manual
  </Accordion>
</AccordionGroup>

### Eventos do Sistema

<AccordionGroup>
  <Accordion title="üîë api_key.revoked">
    **Quando**: API key foi revogada ou expirou
    
    **Use para**:
    - Parar opera√ß√µes automaticamente
    - Notificar administrador urgentemente
    - Redirecionar para renova√ß√£o
    - Registrar evento de seguran√ßa
  </Accordion>
  
  <Accordion title="üí∞ quota.exceeded">
    **Quando**: Cota mensal foi excedida
    
    **Use para**:
    - Bloquear novas submiss√µes
    - Notificar sobre limite atingido
    - Sugerir upgrade de plano
    - Agendar renova√ß√£o autom√°tica
  </Accordion>
  
  <Accordion title="üè• workspace.updated">
    **Quando**: Configura√ß√µes do workspace mudaram
    
    **Use para**:
    - Atualizar configura√ß√µes locais
    - Sincronizar permiss√µes
    - Revalidar acessos
    - Atualizar interface
  </Accordion>
</AccordionGroup>

## Configura√ß√£o e Gerenciamento

### Anatomia de um Webhook

```json
{
  "id": "wh_1234567890abcdef",
  "url": "https://meuapp.com/webhooks/connectvets",
  "events": [
    "note.created",
    "note.completed", 
    "note.failed"
  ],
  "secret": "whsec_abc123def456...",
  "active": true,
  "description": "Webhook principal do sistema",
  "created_at": "2024-02-14T18:00:00Z",
  "last_triggered": "2024-02-14T19:30:15Z",
  "success_rate": 98.5,
  "retry_policy": {
    "max_attempts": 3,
    "backoff_strategy": "exponential"
  }
}
```

### Estrat√©gias de Configura√ß√£o

<CardGroup cols={2}>
  <Card
    title="üéØ Webhook Espec√≠fico"
    icon="target"
  >
    **Um webhook por tipo de evento**
    
    - `/webhooks/notes/created`
    - `/webhooks/notes/completed`
    - `/webhooks/notes/failed`
    
    **Vantagens**: L√≥gica separada, debug f√°cil
    **Desvantagens**: Mais endpoints para manter
  </Card>
  
  <Card
    title="üåê Webhook Universal"
    icon="globe"
  >
    **Um webhook para todos os eventos**
    
    - `/webhooks/connectvets`
    
    **Vantagens**: Simples de configurar
    **Desvantagens**: L√≥gica mais complexa
  </Card>
</CardGroup>

### Configura√ß√£o por Ambiente

```javascript
// Configura√ß√£o recomendada por ambiente
const webhookConfigs = {
  development: {
    url: 'https://ngrok-tunnel.ngrok.io/webhooks/connectvets',
    events: ['note.completed'], // Apenas eventos essenciais
    secret: 'dev_secret_123'
  },
  
  staging: {
    url: 'https://staging.meuapp.com/webhooks/connectvets',
    events: ['note.created', 'note.completed', 'note.failed'],
    secret: 'staging_secret_456'
  },
  
  production: {
    url: 'https://meuapp.com/webhooks/connectvets',
    events: [
      'note.created', 'note.processing', 'note.completed', 
      'note.failed', 'api_key.revoked', 'quota.exceeded'
    ],
    secret: 'prod_secret_ultra_secure_789'
  }
};
```

## Seguran√ßa e Valida√ß√£o

### Verifica√ß√£o de Assinatura

```javascript
// Por que verificar assinatura?
const securityReasons = {
  authentication: "Confirmar que o webhook veio do ConnectVets",
  integrity: "Garantir que dados n√£o foram modificados",
  replay_protection: "Evitar ataques de replay",
  spoofing_prevention: "Impedir webhooks falsos"
};

// Como verificar
function verifyWebhookSignature(payload, signature, secret) {
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex');
  
  const receivedSignature = signature.replace('sha256=', '');
  
  // Compara√ß√£o timing-safe (evita timing attacks)
  return crypto.timingSafeEqual(
    Buffer.from(expectedSignature, 'hex'),
    Buffer.from(receivedSignature, 'hex')
  );
}
```

### Headers de Seguran√ßa

```http
POST /webhooks/connectvets HTTP/1.1
Host: meuapp.com
Content-Type: application/json
X-ConnectVets-Signature: sha256=abc123def456...
X-ConnectVets-Event: note.completed
X-ConnectVets-Delivery: 12345678-1234-1234-1234-123456789abc
X-ConnectVets-Timestamp: 1708024543
User-Agent: ConnectVets-Webhooks/1.0
```

| Header | Descri√ß√£o | Uso |
|--------|-----------|-----|
| `X-ConnectVets-Signature` | Assinatura HMAC-SHA256 | **Valida√ß√£o obrigat√≥ria** |
| `X-ConnectVets-Event` | Tipo do evento | Roteamento r√°pido |
| `X-ConnectVets-Delivery` | ID √∫nico da entrega | Deduplica√ß√£o |
| `X-ConnectVets-Timestamp` | Timestamp Unix | Prote√ß√£o contra replay |

## Padr√µes de Implementa√ß√£o

### Padr√£o B√°sico: Handler Simples

```javascript
// Para aplica√ß√µes pequenas
app.post('/webhooks/connectvets', (req, res) => {
  const event = req.body;
  
  switch (event.type) {
    case 'note.completed':
      updatePatientRecord(event.data.note);
      break;
    case 'note.failed':
      logError(event.data.note);
      break;
  }
  
  res.status(200).send('OK');
});
```

### Padr√£o Avan√ßado: Sistema de Eventos

```javascript
// Para aplica√ß√µes robustas
class WebhookEventSystem {
  constructor() {
    this.handlers = new Map();
    this.middleware = [];
  }
  
  // Registrar handler
  on(eventType, handler) {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, []);
    }
    this.handlers.get(eventType).push(handler);
  }
  
  // Middleware (valida√ß√£o, logging, etc.)
  use(middleware) {
    this.middleware.push(middleware);
  }
  
  // Processar evento
  async emit(event) {
    // Executar middleware
    for (const middleware of this.middleware) {
      await middleware(event);
    }
    
    // Executar handlers
    const handlers = this.handlers.get(event.type) || [];
    await Promise.all(handlers.map(handler => handler(event)));
  }
}

// Uso
const webhookSystem = new WebhookEventSystem();

webhookSystem.use(validateSignature);
webhookSystem.use(logEvent);
webhookSystem.use(deduplicateEvent);

webhookSystem.on('note.completed', updatePatientRecord);
webhookSystem.on('note.completed', notifyVeterinarian);
webhookSystem.on('note.completed', sendCompletionEmail);
```

### Padr√£o Enterprise: Message Queue

```javascript
// Para alta escala e confiabilidade
class WebhookProcessor {
  constructor(queue) {
    this.queue = queue; // Redis, RabbitMQ, AWS SQS, etc.
  }
  
  // Receber webhook (r√°pido)
  async receiveWebhook(req, res) {
    try {
      // Valida√ß√£o b√°sica e r√°pida
      this.validateRequest(req);
      
      // Adicionar √† fila para processamento ass√≠ncrono
      await this.queue.add('process-webhook', {
        headers: req.headers,
        body: req.body,
        timestamp: Date.now()
      });
      
      // Responder imediatamente
      res.status(200).send('Queued');
      
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }
  
  // Processar webhook (ass√≠ncrono)
  async processWebhook(job) {
    const { headers, body } = job.data;
    
    // Valida√ß√£o completa
    await this.fullValidation(headers, body);
    
    // Processamento business logic
    await this.handleEvent(body);
    
    // Marcar como processado
    await this.markAsProcessed(body.id);
  }
}
```

## Monitoramento e Observabilidade

### M√©tricas Importantes

<CardGroup cols={2}>
  <Card
    title="üìä M√©tricas de Entrega"
    icon="chart-line"
  >
    - **Taxa de sucesso** (target: >99%)
    - **Lat√™ncia de entrega** (target: &lt;2s)
    - **Taxa de retry** (target: &lt;5%)
    - **Eventos perdidos** (target: 0)
  </Card>
  
  <Card
    title="‚ö° M√©tricas de Performance"
    icon="zap"
  >
    - **Tempo de processamento** (target: &lt;1s)
    - **Throughput** (eventos/segundo)
    - **Memory/CPU usage**
    - **Tempo de resposta** HTTP
  </Card>
</CardGroup>

### Dashboard de Webhooks

```javascript
// M√©tricas que devem ser monitoradas
const webhookMetrics = {
  delivery: {
    total_sent: 15847,
    successful: 15691,
    failed: 156,
    success_rate: 99.01 // %
  },
  
  performance: {
    avg_response_time: 245, // ms
    p95_response_time: 890, // ms
    avg_payload_size: 2.3, // KB
    throughput: 125 // eventos/min
  },
  
  errors: {
    timeout_count: 23,
    http_errors: {
      '400': 12,
      '500': 8,
      '503': 5
    },
    signature_failures: 2
  },
  
  recent_events: [
    { type: 'note.completed', timestamp: '2024-02-14T19:45:32Z', status: 'success' },
    { type: 'note.failed', timestamp: '2024-02-14T19:45:28Z', status: 'success' },
    // ...
  ]
};
```

## Troubleshooting e Debug

### Problemas Comuns

<AccordionGroup>
  <Accordion title="üö´ Webhooks n√£o chegam">
    **Poss√≠veis causas:**
    - URL incorreta ou inacess√≠vel
    - Firewall bloqueando ConnectVets
    - Webhook desativado
    - Evento n√£o inscrito
    
    **Debug:**
    ```bash
    # Testar acessibilidade
    curl -X POST https://meuapp.com/webhooks/connectvets \
         -H "Content-Type: application/json" \
         -d '{"test": true}'
    
    # Verificar logs do servidor
    tail -f /var/log/webhook.log
    
    # Testar webhook via dashboard
    POST /webhooks/{id}/test
    ```
  </Accordion>
  
  <Accordion title="‚ùå Falhas de assinatura">
    **Poss√≠veis causas:**
    - Secret incorreto
    - Modifica√ß√£o do payload
    - Codifica√ß√£o de caracteres
    - Timing de verifica√ß√£o
    
    **Debug:**
    ```javascript
    // Log detalhado da verifica√ß√£o
    console.log('Received signature:', req.headers['x-connectvets-signature']);
    console.log('Payload:', req.rawBody);
    console.log('Expected signature:', expectedSignature);
    console.log('Secret used:', webhookSecret.substring(0, 8) + '...');
    ```
  </Accordion>
  
  <Accordion title="üêå Timeouts frequentes">
    **Poss√≠veis causas:**
    - Processamento muito lento
    - Opera√ß√µes s√≠ncronas pesadas
    - Depend√™ncias externas lentas
    - Recursos insuficientes
    
    **Solu√ß√µes:**
    ```javascript
    // Responder rapidamente + processar async
    app.post('/webhooks', (req, res) => {
      res.status(200).send('OK'); // Responder primeiro
      
      // Processar depois
      setImmediate(() => {
        processWebhookAsync(req.body);
      });
    });
    ```
  </Accordion>
</AccordionGroup>

### Ferramentas de Debug

```javascript
// Webhook debugger para desenvolvimento
class WebhookDebugger {
  constructor() {
    this.events = [];
    this.maxEvents = 100;
  }
  
  logEvent(event, metadata = {}) {
    this.events.unshift({
      ...event,
      debug: {
        timestamp: new Date(),
        headers: metadata.headers,
        signature_valid: metadata.signatureValid,
        processing_time: metadata.processingTime
      }
    });
    
    // Manter apenas √∫ltimos eventos
    if (this.events.length > this.maxEvents) {
      this.events = this.events.slice(0, this.maxEvents);
    }
  }
  
  getRecentEvents(count = 20) {
    return this.events.slice(0, count);
  }
  
  getEventStats() {
    return {
      total: this.events.length,
      by_type: this.groupBy(this.events, 'type'),
      avg_processing_time: this.average(this.events, 'debug.processing_time')
    };
  }
}
```

## Migra√ß√£o: Polling ‚Üí Webhooks

### Estrat√©gia de Migra√ß√£o

<Steps>
  <Step title="Fase 1: Implementa√ß√£o Paralela">
    Manter polling existente + implementar webhooks
    - Webhooks para eventos cr√≠ticos
    - Polling como backup/fallback
  </Step>
  
  <Step title="Fase 2: Valida√ß√£o">
    Comparar resultados entre polling e webhooks
    - Verificar consist√™ncia de dados
    - Medir performance e confiabilidade
  </Step>
  
  <Step title="Fase 3: Transi√ß√£o Gradual">
    Migrar funcionalidades uma por uma
    - Come√ßar com funcionalidades menos cr√≠ticas
    - Monitorar m√©tricas atentamente
  </Step>
  
  <Step title="Fase 4: Desativa√ß√£o do Polling">
    Remover polling quando webhooks estiverem est√°veis
    - Manter como emergency fallback
    - Documentar processo de rollback
  </Step>
</Steps>

### C√≥digo de Migra√ß√£o

```javascript
class HybridNotificationSystem {
  constructor() {
    this.useWebhooks = process.env.USE_WEBHOOKS === 'true';
    this.pollingInterval = 30000; // 30s fallback
  }
  
  async processNote(noteId) {
    if (this.useWebhooks) {
      // Webhook mode: apenas aguardar notifica√ß√£o
      return this.waitForWebhook(noteId);
    } else {
      // Polling mode: verificar status periodicamente
      return this.pollNoteStatus(noteId);
    }
  }
  
  async waitForWebhook(noteId, timeout = 300000) {
    return new Promise((resolve, reject) => {
      // Configurar listener para webhook
      this.once(`note.completed.${noteId}`, resolve);
      this.once(`note.failed.${noteId}`, reject);
      
      // Timeout como fallback
      setTimeout(() => {
        reject(new Error('Webhook timeout'));
      }, timeout);
    });
  }
  
  // Fallback para polling em caso de falha de webhook
  async emergencyPolling(noteId) {
    console.warn('üö® Fallback para polling devido a falha de webhook');
    return this.pollNoteStatus(noteId);
  }
}
```

## Pr√≥ximos Passos

<CardGroup cols={2}>
  <Card
    title="Webhook Handling"
    icon="webhook"
    href="/examples/webhook-handling"
  >
    Implementa√ß√£o pr√°tica completa
  </Card>
  <Card
    title="API Keys"
    icon="key"
    href="/concepts/api-keys"
  >
    Como funcionam as chaves de API
  </Card>
  <Card
    title="Tenants e Workspaces"
    icon="building"
    href="/concepts/tenants"
  >
    Sistema multi-tenant
  </Card>
  <Card
    title="Error Handling"
    icon="alert-triangle"
    href="/integration/error-handling"
  >
    Tratamento robusto de erros
  </Card>
</CardGroup> 