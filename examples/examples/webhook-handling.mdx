---
title: 'Webhook Handling'
description: 'Implementar webhooks para receber notifica√ß√µes autom√°ticas do ConnectVets Notes'
---

## Vis√£o Geral

Os **webhooks** permitem que sua aplica√ß√£o receba notifica√ß√µes autom√°ticas quando eventos importantes acontecem no ConnectVets Notes, como conclus√£o de processamento, falhas ou atualiza√ß√µes de status.

<Info>
  **Vantagem**: Elimina a necessidade de polling constante e garante resposta imediata aos eventos.
</Info>

## Eventos Suportados

### Tipos de Eventos

| Evento | Descri√ß√£o | Quando Ocorre |
|--------|-----------|---------------|
| `note.created` | Nova nota criada | Ap√≥s upload bem-sucedido |
| `note.processing` | Processamento iniciado | Quando sai da fila |
| `note.completed` | Processamento conclu√≠do | Transcri√ß√£o e an√°lise prontas |
| `note.failed` | Processamento falhou | Erro durante processamento |
| `note.updated` | Nota atualizada | Modifica√ß√µes manuais |

### Estrutura do Payload

```json
{
  "id": "evt_1234567890abcdef",
  "type": "note.completed",
  "created_at": "2024-02-14T18:25:43Z",
  "data": {
    "note": {
      "id": "note_abc123def456",
      "status": "completed",
      "created_at": "2024-02-14T18:20:00Z",
      "updated_at": "2024-02-14T18:25:43Z",
      "metadata": {
        "patient_name": "Rex",
        "doctor_name": "Dr. Silva",
        "species": "Canino",
        "consultation_type": "consulta"
      },
      "sections": [
        {
          "type": "summary",
          "content": "Consulta de rotina para c√£o de 5 anos..."
        },
        {
          "type": "diagnosis", 
          "content": "Animal saud√°vel, sem altera√ß√µes..."
        }
      ],
      "transcript": "Transcri√ß√£o completa da consulta..."
    }
  }
}
```

## Implementa√ß√£o do Servidor

### Node.js + Express

```javascript
const express = require('express');
const crypto = require('crypto');
const bodyParser = require('body-parser');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware para verificar assinatura do webhook
app.use('/webhooks/connectvets', bodyParser.raw({ type: 'application/json' }));

// Chave secreta do webhook (configure no dashboard)
const WEBHOOK_SECRET = process.env.CONNECTVETS_WEBHOOK_SECRET;

class WebhookHandler {
    constructor() {
        this.eventHandlers = new Map();
        this.setupEventHandlers();
    }

    // Configurar handlers para cada tipo de evento
    setupEventHandlers() {
        this.eventHandlers.set('note.created', this.handleNoteCreated.bind(this));
        this.eventHandlers.set('note.processing', this.handleNoteProcessing.bind(this));
        this.eventHandlers.set('note.completed', this.handleNoteCompleted.bind(this));
        this.eventHandlers.set('note.failed', this.handleNoteFailed.bind(this));
        this.eventHandlers.set('note.updated', this.handleNoteUpdated.bind(this));
    }

    // Verificar assinatura do webhook
    verifySignature(payload, signature) {
        const expectedSignature = crypto
            .createHmac('sha256', WEBHOOK_SECRET)
            .update(payload)
            .digest('hex');
        
        const receivedSignature = signature.replace('sha256=', '');
        
        return crypto.timingSafeEqual(
            Buffer.from(expectedSignature, 'hex'),
            Buffer.from(receivedSignature, 'hex')
        );
    }

    // Processar webhook recebido
    async processWebhook(req, res) {
        try {
            const signature = req.headers['x-connectvets-signature'];
            const payload = req.body;

            // Verificar assinatura
            if (!this.verifySignature(payload, signature)) {
                console.error('‚ùå Assinatura inv√°lida do webhook');
                return res.status(401).send('Unauthorized');
            }

            // Parse do payload
            const event = JSON.parse(payload.toString());
            
            console.log(`üîî Webhook recebido: ${event.type} (${event.id})`);

            // Processar evento
            const handler = this.eventHandlers.get(event.type);
            if (handler) {
                await handler(event);
            } else {
                console.warn(`‚ö†Ô∏è Evento n√£o tratado: ${event.type}`);
            }

            // Resposta de sucesso
            res.status(200).send('OK');

        } catch (error) {
            console.error('‚ùå Erro ao processar webhook:', error);
            res.status(500).send('Internal Server Error');
        }
    }

    // Handler: Nota criada
    async handleNoteCreated(event) {
        const note = event.data.note;
        
        console.log(`üìù Nova nota criada: ${note.id}`);
        console.log(`üë§ Paciente: ${note.metadata.patient_name}`);
        console.log(`üë®‚Äç‚öïÔ∏è Veterin√°rio: ${note.metadata.doctor_name}`);

        // Integrar com seu sistema
        await this.createPatientRecord(note);
        await this.notifyVeterinarian(note, 'created');
        
        // Registrar no banco de dados
        await this.saveWebhookEvent(event);
    }

    // Handler: Processamento iniciado
    async handleNoteProcessing(event) {
        const note = event.data.note;
        
        console.log(`üîÑ Processamento iniciado: ${note.id}`);
        
        // Atualizar status na interface
        await this.updateNoteStatus(note.id, 'processing');
        
        // Notificar usu√°rio sobre in√≠cio do processamento
        await this.notifyUser(note.metadata.doctor_name, 
            `Processamento da consulta de ${note.metadata.patient_name} iniciado`);
    }

    // Handler: Processamento conclu√≠do
    async handleNoteCompleted(event) {
        const note = event.data.note;
        
        console.log(`‚úÖ Processamento conclu√≠do: ${note.id}`);
        console.log(`üìã Se√ß√µes geradas: ${note.sections.length}`);

        // Extrair informa√ß√µes estruturadas
        const summary = note.sections.find(s => s.type === 'summary')?.content;
        const diagnosis = note.sections.find(s => s.type === 'diagnosis')?.content;
        const treatment = note.sections.find(s => s.type === 'treatment')?.content;

        // Atualizar prontu√°rio do paciente
        await this.updatePatientRecord(note.id, {
            summary,
            diagnosis,
            treatment,
            full_transcript: note.transcript,
            consultation_date: note.created_at
        });

        // Notificar veterin√°rio
        await this.notifyVeterinarian(note, 'completed');
        
        // Enviar por email se configurado
        await this.sendCompletionEmail(note);
        
        // Atualizar dashboard em tempo real
        await this.broadcastToWebSockets('note_completed', note);
    }

    // Handler: Processamento falhou
    async handleNoteFailed(event) {
        const note = event.data.note;
        
        console.error(`‚ùå Processamento falhou: ${note.id}`);
        console.error(`üí¨ Erro: ${note.error_message}`);

        // Registrar erro
        await this.logProcessingError(note);
        
        // Notificar administrador
        await this.notifyAdmin(note, 'failed');
        
        // Marcar para reprocessamento manual se necess√°rio
        if (this.canRetryProcessing(note)) {
            await this.scheduleRetry(note.id);
        }
    }

    // Handler: Nota atualizada
    async handleNoteUpdated(event) {
        const note = event.data.note;
        
        console.log(`üìù Nota atualizada: ${note.id}`);
        
        // Sincronizar altera√ß√µes
        await this.syncNoteUpdates(note);
        
        // Notificar sobre altera√ß√µes
        await this.notifyAboutUpdates(note);
    }

    // Integra√ß√£o com sistema interno
    async createPatientRecord(note) {
        // Implementar cria√ß√£o/atualiza√ß√£o do prontu√°rio
        console.log('üíæ Criando/atualizando prontu√°rio...');
        
        const patientData = {
            name: note.metadata.patient_name,
            species: note.metadata.species,
            last_consultation: note.created_at,
            veterinarian: note.metadata.doctor_name,
            connectvets_note_id: note.id
        };
        
        // Salvar no seu banco de dados
        // await YourDatabase.savePatient(patientData);
    }

    async updatePatientRecord(noteId, consultationData) {
        console.log('üìù Atualizando prontu√°rio com resultados...');
        
        // Atualizar consulta no banco
        // await YourDatabase.updateConsultation(noteId, consultationData);
    }

    // Notifica√ß√µes
    async notifyVeterinarian(note, eventType) {
        const messages = {
            created: `üìã Nova consulta de ${note.metadata.patient_name} foi enviada para processamento`,
            completed: `‚úÖ An√°lise da consulta de ${note.metadata.patient_name} est√° pronta`
        };
        
        const message = messages[eventType];
        if (message) {
            // Enviar notifica√ß√£o push, email, SMS, etc.
            console.log(`üì± Notificando ${note.metadata.doctor_name}: ${message}`);
            
            // Implementar notifica√ß√£o real
            // await this.sendPushNotification(note.metadata.doctor_name, message);
        }
    }

    async sendCompletionEmail(note) {
        const emailData = {
            to: this.getVeterinarianEmail(note.metadata.doctor_name),
            subject: `An√°lise da consulta de ${note.metadata.patient_name} conclu√≠da`,
            template: 'consultation_completed',
            data: {
                patientName: note.metadata.patient_name,
                doctorName: note.metadata.doctor_name,
                consultationDate: new Date(note.created_at).toLocaleDateString('pt-BR'),
                noteId: note.id,
                summary: note.sections.find(s => s.type === 'summary')?.content
            }
        };
        
        // Enviar email
        // await this.emailService.send(emailData);
        console.log(`üìß Email de conclus√£o enviado para ${emailData.to}`);
    }

    // WebSocket para updates em tempo real
    async broadcastToWebSockets(event, data) {
        // Implementar broadcast WebSocket
        console.log(`üîÑ Broadcasting ${event} para clientes conectados`);
        
        // this.wss.clients.forEach(client => {
        //     if (client.readyState === WebSocket.OPEN) {
        //         client.send(JSON.stringify({ event, data }));
        //     }
        // });
    }

    // Helpers
    getVeterinarianEmail(doctorName) {
        // Buscar email do veterin√°rio no banco
        return 'veterinario@clinica.com';
    }

    canRetryProcessing(note) {
        // Verificar se o erro permite retry
        const retryableErrors = ['temporary_error', 'service_unavailable'];
        return retryableErrors.includes(note.error_code);
    }

    async scheduleRetry(noteId) {
        // Agendar reprocessamento
        console.log(`üîÑ Agendando retry para nota: ${noteId}`);
        // Implementar sistema de retry
    }

    async saveWebhookEvent(event) {
        // Salvar evento para auditoria
        console.log(`üíæ Salvando evento webhook: ${event.id}`);
        // await YourDatabase.saveWebhookEvent(event);
    }
}

// Inicializar handler
const webhookHandler = new WebhookHandler();

// Rota do webhook
app.post('/webhooks/connectvets', (req, res) => {
    webhookHandler.processWebhook(req, res);
});

// Rota de sa√∫de
app.get('/health', (req, res) => {
    res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Iniciar servidor
app.listen(PORT, () => {
    console.log(`üöÄ Servidor webhook rodando na porta ${PORT}`);
    console.log(`üì° Endpoint: http://localhost:${PORT}/webhooks/connectvets`);
});

module.exports = { WebhookHandler };
```

### Python + Flask

```python
from flask import Flask, request, jsonify
import hmac
import hashlib
import json
import logging
from datetime import datetime

app = Flask(__name__)
logging.basicConfig(level=logging.INFO)

# Configura√ß√£o
WEBHOOK_SECRET = 'sua_chave_secreta_aqui'

class WebhookHandler:
    def __init__(self):
        self.event_handlers = {
            'note.created': self.handle_note_created,
            'note.processing': self.handle_note_processing,
            'note.completed': self.handle_note_completed,
            'note.failed': self.handle_note_failed,
            'note.updated': self.handle_note_updated
        }
    
    def verify_signature(self, payload, signature):
        """Verificar assinatura do webhook"""
        expected_signature = hmac.new(
            WEBHOOK_SECRET.encode('utf-8'),
            payload,
            hashlib.sha256
        ).hexdigest()
        
        received_signature = signature.replace('sha256=', '')
        return hmac.compare_digest(expected_signature, received_signature)
    
    def process_webhook(self, request):
        """Processar webhook recebido"""
        try:
            signature = request.headers.get('X-ConnectVets-Signature')
            payload = request.get_data()
            
            # Verificar assinatura
            if not self.verify_signature(payload, signature):
                logging.error('‚ùå Assinatura inv√°lida do webhook')
                return {'error': 'Unauthorized'}, 401
            
            # Parse do evento
            event = json.loads(payload.decode('utf-8'))
            logging.info(f"üîî Webhook recebido: {event['type']} ({event['id']})")
            
            # Processar evento
            handler = self.event_handlers.get(event['type'])
            if handler:
                handler(event)
            else:
                logging.warning(f"‚ö†Ô∏è Evento n√£o tratado: {event['type']}")
            
            return {'status': 'success'}, 200
            
        except Exception as e:
            logging.error(f"‚ùå Erro ao processar webhook: {str(e)}")
            return {'error': 'Internal Server Error'}, 500
    
    def handle_note_created(self, event):
        """Handler para nota criada"""
        note = event['data']['note']
        logging.info(f"üìù Nova nota criada: {note['id']}")
        
        # Implementar l√≥gica espec√≠fica
        self.create_patient_record(note)
        self.notify_veterinarian(note, 'created')
    
    def handle_note_completed(self, event):
        """Handler para processamento conclu√≠do"""
        note = event['data']['note']
        logging.info(f"‚úÖ Processamento conclu√≠do: {note['id']}")
        
        # Extrair se√ß√µes
        sections = {s['type']: s['content'] for s in note.get('sections', [])}
        
        # Atualizar prontu√°rio
        self.update_patient_record(note['id'], {
            'summary': sections.get('summary'),
            'diagnosis': sections.get('diagnosis'),
            'treatment': sections.get('treatment'),
            'transcript': note.get('transcript')
        })
        
        # Notificar veterin√°rio
        self.notify_veterinarian(note, 'completed')
    
    def handle_note_failed(self, event):
        """Handler para processamento falhou"""
        note = event['data']['note']
        logging.error(f"‚ùå Processamento falhou: {note['id']}")
        
        # Registrar erro e notificar admin
        self.log_processing_error(note)
        self.notify_admin(note)
    
    def handle_note_processing(self, event):
        """Handler para processamento iniciado"""
        note = event['data']['note']
        logging.info(f"üîÑ Processamento iniciado: {note['id']}")
        
        self.update_note_status(note['id'], 'processing')
    
    def handle_note_updated(self, event):
        """Handler para nota atualizada"""
        note = event['data']['note']
        logging.info(f"üìù Nota atualizada: {note['id']}")
        
        self.sync_note_updates(note)
    
    # M√©todos de integra√ß√£o (implementar conforme necess√°rio)
    def create_patient_record(self, note):
        logging.info("üíæ Criando prontu√°rio do paciente")
        # Implementar integra√ß√£o com banco de dados
    
    def update_patient_record(self, note_id, data):
        logging.info("üìù Atualizando prontu√°rio")
        # Implementar atualiza√ß√£o do prontu√°rio
    
    def notify_veterinarian(self, note, event_type):
        logging.info(f"üì± Notificando veterin√°rio: {event_type}")
        # Implementar notifica√ß√£o (email, push, SMS)
    
    def log_processing_error(self, note):
        logging.error(f"üìã Registrando erro de processamento: {note['id']}")
        # Implementar log de erros
    
    def notify_admin(self, note):
        logging.info("üö® Notificando administrador sobre erro")
        # Implementar notifica√ß√£o de erro para admin

# Inicializar handler
webhook_handler = WebhookHandler()

@app.route('/webhooks/connectvets', methods=['POST'])
def webhook_endpoint():
    """Endpoint do webhook"""
    return webhook_handler.process_webhook(request)

@app.route('/health', methods=['GET'])
def health_check():
    """Check de sa√∫de"""
    return jsonify({
        'status': 'ok',
        'timestamp': datetime.now().isoformat()
    })

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
```

## Configura√ß√£o dos Webhooks

### 1. Registrar Webhook via API

```javascript
async function registerWebhook() {
    const webhookData = {
        url: 'https://meuapp.com/webhooks/connectvets',
        events: [
            'note.created',
            'note.completed', 
            'note.failed'
        ],
        secret: 'minha_chave_secreta_super_segura',
        active: true,
        description: 'Webhook principal do sistema veterin√°rio'
    };

    try {
        const response = await fetch('https://api.connectvets.com/webhooks', {
            method: 'POST',
            headers: {
                'X-API-KEY': 'sua_api_key',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(webhookData)
        });

        if (response.ok) {
            const webhook = await response.json();
            console.log('‚úÖ Webhook registrado:', webhook.id);
            return webhook;
        }
    } catch (error) {
        console.error('‚ùå Erro ao registrar webhook:', error);
    }
}
```

### 2. Gerenciar Webhooks

```javascript
class WebhookManager {
    constructor(apiKey) {
        this.apiKey = apiKey;
        this.baseUrl = 'https://api.connectvets.com';
    }

    // Listar webhooks
    async listWebhooks() {
        const response = await this.request('/webhooks');
        return response.data;
    }

    // Obter webhook espec√≠fico
    async getWebhook(webhookId) {
        return this.request(`/webhooks/${webhookId}`);
    }

    // Atualizar webhook
    async updateWebhook(webhookId, updates) {
        return this.request(`/webhooks/${webhookId}`, {
            method: 'PATCH',
            body: JSON.stringify(updates)
        });
    }

    // Deletar webhook
    async deleteWebhook(webhookId) {
        return this.request(`/webhooks/${webhookId}`, {
            method: 'DELETE'
        });
    }

    // Testar webhook
    async testWebhook(webhookId, eventType = 'note.completed') {
        return this.request(`/webhooks/${webhookId}/test`, {
            method: 'POST',
            body: JSON.stringify({ event_type: eventType })
        });
    }

    // Reenviar evento
    async retryEvent(eventId) {
        return this.request(`/webhook-events/${eventId}/retry`, {
            method: 'POST'
        });
    }

    async request(endpoint, options = {}) {
        const response = await fetch(`${this.baseUrl}${endpoint}`, {
            ...options,
            headers: {
                'X-API-KEY': this.apiKey,
                'Content-Type': 'application/json',
                ...options.headers
            }
        });

        if (!response.ok) {
            throw new Error(`API Error: ${response.status}`);
        }

        return response.json();
    }
}
```

## Monitoramento e Debug

### Dashboard de Webhooks

```javascript
class WebhookDashboard {
    constructor() {
        this.events = [];
        this.stats = {
            total: 0,
            successful: 0,
            failed: 0,
            lastEvent: null
        };
    }

    // Registrar evento webhook
    logEvent(event, status, responseTime) {
        const logEntry = {
            id: event.id,
            type: event.type,
            timestamp: new Date(event.created_at),
            status: status, // 'success', 'failed', 'timeout'
            responseTime: responseTime,
            noteId: event.data.note?.id
        };

        this.events.unshift(logEntry);
        
        // Manter apenas √∫ltimos 1000 eventos
        if (this.events.length > 1000) {
            this.events = this.events.slice(0, 1000);
        }

        this.updateStats();
        this.renderDashboard();
    }

    updateStats() {
        this.stats.total = this.events.length;
        this.stats.successful = this.events.filter(e => e.status === 'success').length;
        this.stats.failed = this.events.filter(e => e.status === 'failed').length;
        this.stats.lastEvent = this.events[0]?.timestamp;
        
        // Taxa de sucesso
        this.stats.successRate = this.stats.total > 0 
            ? (this.stats.successful / this.stats.total * 100).toFixed(1)
            : 0;
    }

    renderDashboard() {
        const dashboard = document.getElementById('webhook-dashboard');
        if (!dashboard) return;

        dashboard.innerHTML = `
            <div class="webhook-stats">
                <div class="stat-card">
                    <h3>üìä Total de Eventos</h3>
                    <p class="stat-number">${this.stats.total}</p>
                </div>
                
                <div class="stat-card">
                    <h3>‚úÖ Taxa de Sucesso</h3>
                    <p class="stat-number">${this.stats.successRate}%</p>
                </div>
                
                <div class="stat-card">
                    <h3>‚ùå Falhas</h3>
                    <p class="stat-number">${this.stats.failed}</p>
                </div>
                
                <div class="stat-card">
                    <h3>üïê √öltimo Evento</h3>
                    <p class="stat-text">${this.stats.lastEvent ? 
                        this.stats.lastEvent.toLocaleString('pt-BR') : 'Nenhum'}</p>
                </div>
            </div>
            
            <div class="webhook-events">
                <h3>üìã Eventos Recentes</h3>
                <div class="events-list">
                    ${this.events.slice(0, 20).map(event => `
                        <div class="event-item ${event.status}">
                            <span class="event-type">${event.type}</span>
                            <span class="event-time">${event.timestamp.toLocaleTimeString('pt-BR')}</span>
                            <span class="event-status">${this.getStatusIcon(event.status)}</span>
                            <span class="event-response-time">${event.responseTime}ms</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    getStatusIcon(status) {
        const icons = {
            'success': '‚úÖ',
            'failed': '‚ùå',
            'timeout': '‚è±Ô∏è'
        };
        return icons[status] || '‚ùì';
    }
}

// Inicializar dashboard
const webhookDashboard = new WebhookDashboard();
```

## Melhores Pr√°ticas

### Seguran√ßa
- ‚úÖ **Sempre verificar assinatura** dos webhooks
- ‚úÖ **Usar HTTPS** em produ√ß√£o
- ‚úÖ **Rotacionar secrets** periodicamente
- ‚úÖ **Validar payload** antes de processar

### Performance
- ‚úÖ **Processar eventos de forma ass√≠ncrona**
- ‚úÖ **Implementar timeout** adequado
- ‚úÖ **Usar queue** para eventos pesados
- ‚úÖ **Responder rapidamente** (< 5 segundos)

### Confiabilidade
- ‚úÖ **Implementar retry** autom√°tico
- ‚úÖ **Log de todos os eventos**
- ‚úÖ **Monitoramento ativo**
- ‚úÖ **Alertas para falhas consecutivas**

### C√≥digo Defensivo

```javascript
class RobustWebhookHandler {
    async processWebhook(req, res) {
        const startTime = Date.now();
        
        try {
            // Timeout de 30 segundos
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Timeout')), 30000));
            
            const processingPromise = this.handleEventSafely(req);
            
            await Promise.race([processingPromise, timeoutPromise]);
            
            const responseTime = Date.now() - startTime;
            this.logSuccess(req, responseTime);
            
            res.status(200).send('OK');
            
        } catch (error) {
            const responseTime = Date.now() - startTime;
            this.logError(req, error, responseTime);
            
            // Sempre responder com sucesso para evitar retry desnecess√°rio
            res.status(200).send('Error logged');
        }
    }
    
    async handleEventSafely(req) {
        // Implementar com try-catch interno
        // Nunca deixar erro n√£o capturado
    }
}
```

## Pr√≥ximos Passos

<CardGroup cols={2}>
  <Card
    title="Integra√ß√£o B√°sica"
    icon="play"
    href="/examples/basic-integration"
  >
    Voltar ao exemplo b√°sico
  </Card>
  <Card
    title="Filtros Avan√ßados"
    icon="filter"
    href="/examples/advanced-filtering"
  >
    Sistema de busca inteligente
  </Card>
  <Card
    title="Error Handling"
    icon="alert-triangle"
    href="/integration/error-handling"
  >
    Estrat√©gias robustas de recovery
  </Card>
  <Card
    title="API Reference"
    icon="book"
    href="/api-reference/overview"
  >
    Documenta√ß√£o completa da API
  </Card>
</CardGroup> 